<template>
  <div class="container">
    <h1>CS Concepts to boost your Programming skill</h1>
    <p>If you are not from a Computer science background and you find yourself as a programmer, coding, developing applications, website and more. You might think that is all and telling yourself with time you will gain the knowledge to build an operating system or magically know how your favourite programming language works.</p>

    <p>I was once like coming from a non-CS background that hoping one day if I program HTML and CSS well enough I would stumble on the magically secret of how the computer works.</p>

    <p>I saw a lot of computer science topics like Algorithm and Data Structures, compiler, Operating system but never felt the need to explore them deeply as I was already doing well building websites and mobile applications without them.</p>

    <p>But as I code more and started to work on more complex projects, I realised that I was missing a lot of knowledge that would have made my life easier. I was spending a lot of time trying to figure out how things work and why they work the way they do.</p>

    <img src="~/assets/images/pcha/book.jpeg" alt="CS Concepts" class="img-fluid">

    <p>My first eureka was when I picked up Algorithm and Data Structures and after some time I was able to apply it to solve some of my bugging programming challeges. This immediately made me realise how much Computer Science knowledge would have made me a better programmer.</p>

    <p>That eureka moment with Algorithms and Data Structures completely changed my mindset. I began to see programming not just as writing code that works, but as solving problems with clarity, precision, and efficiency. Suddenly, terms like Big O notation, binary search, hash tables, and trees weren’t just academic jargon, they were tools that directly improved how I built software.
    </p>

    <div>
      <h2>1. Algorithms & Data Structures (DSA)</h2>
      <p>Understanding DSA gave me the mental models to approach problems more intelligently. Instead of brute-forcing solutions, I could now analyze and choose the right data structure for the job. Algorithms gave me shortcuts and deeper insights into why some approaches were better than others.</p>
    </div>


    <div>
      <h2>2. Compiler Theory</h2>

      <p>Understading Compiler Theory, and it was like opening a black box. I used to take for granted that my code “just ran,” but learning about lexical analysis, parsing, intermediate code generation, and optimization passes made me appreciate what languages like JavaScript or Python are doing under the hood.</p>

      <p>Understanding compilers also made me write cleaner, more efficient code because I understood how my instructions were interpreted and transformed into machine-level operations.</p>
    </div>

    <div>
      <h2>3. Operating Systems</h2>

      <p>When I started learning about Operating Systems. At first, I didn’t see the relevance as I wasn’t building an OS, right? But once I understood process management, memory allocation, I/O operations, and file systems, I saw how deeply these concepts impacted my programs.</p>

      <p>I stopped writing memory-hungry applications and started caring about thread safety, file locks, and how the OS manages concurrency. It also helped me debug problems I previously knew no clue on how to solve.</p>
    </div>

    <div>
      <h2>4. System Design</h2>
      <p>
        As I moved into building scalable systems and working on backend architecture, System Design became essential. Concepts like load balancing, caching, CDNs, message queues, and databases sharding helped me design systems that didn’t just work but also scale.
      </p>
      <p>
        Knowing about CAP theorem, eventual consistency, and microservices architecture made me see the big picture. I could now talk to DevOps teams, backend engineers, and architects with more understanding.
      </p>
    </div>

    <div>
      <h2>5. Concurrency, Parallelism, and Multithreading</h2>
      <p>
        In high-performance apps, Concurrency and Parallelism became game-changers. I learned that:

        Concurrency is about managing multiple tasks at once (like handling multiple users),

        While Parallelism is about doing multiple things at the exact same time (on multiple cores).
      </p>

      <p>
        Concepts like deadlocks, race conditions, and mutexes started to matter when my applications started dealing with multiple threads or async operations. Understanding these helped me write safer, faster, and more responsive programs.
      </p>
    </div>

    <div>
      <h2>6. Networking</h2>
      <p>
        I used to think of networking as just connecting to the internet. But learning about TCP/IP, HTTP/HTTPS, DNS, and how data travels across networks made me a better web developer. I understood latency, bandwidth, and how to optimize my applications for different network conditions.
      </p>
      <p>
        This knowledge also helped me debug network-related issues and understand the importance of security protocols.
      </p>
    </div>

    <div>
      <h2>Final Thoughts</h2>
      <p>Learning these Computer Science fundamentals didn’t just make me a better programmer as it made me a more confident and capable one. I now build software with a deeper understanding of what’s happening behind the scenes. Whether it’s debugging an issue, optimizing performance, designing a robust system, or securing communication. CS concepts are the tools that guide me.</p>
    </div>
  </div>
</template>

<script setup></script>
